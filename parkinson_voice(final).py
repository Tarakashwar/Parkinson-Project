# -*- coding: utf-8 -*-
"""Parkinson_voice(Final).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qYX1od3e4kbVFX-h9pbkNpb007Kxchc8
"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Activation
from tensorflow.keras.optimizers import Adam
import numpy as np
import pandas as pd
from google.colab import files
from sklearn.model_selection import train_test_split
from sklearn import metrics
import io
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score

uploaded = files.upload()
df = pd.read_csv(io.BytesIO(uploaded['parkinsons2.csv']))

#Preview of dataset...
df.loc[:]

X = df.drop('status',axis =1).values
y = df['status'].values
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=101)
 

print("Train Dataset:")
print(X_train)
print("Test Dataset:")

print(y_test)

model = Sequential()
model.add(Dense(20,input_dim=22,activation='sigmoid'))
model.add(Dense(10,activation='sigmoid'))
model.add(Dense(15,activation='sigmoid'))
#model.add(Dense(50,activation='sigmoid'))
#model.add(Dense(70,activation='relu'))
model.add(Dense(1,activation='sigmoid'))

#Compileing defined model.......

model.compile(optimizer='Adam',loss='mse',metrics=['accuracy'])
 
history=model.fit(X_train,y_train,batch_size=11,epochs=5000,validation_data=(X_test,y_test))

#Prediction process.....

y_pred = model.predict(X_test)
print("Predicted output:.....")
print(y_pred)
print("Original output:.....")

print('MAE:', metrics.mean_absolute_error(y_test, y_pred))  
print('MSE:', metrics.mean_squared_error(y_test, y_pred))  
print('RMSE:', np.sqrt(metrics.mean_squared_error(y_test, y_pred)))
print('VarScore:',metrics.explained_variance_score(y_test,y_pred))

Predicted_output = []
for i in range(len(y_pred)):
  if(y_pred[i]>0.5):
    Predicted_output.append(1)
    print('%.2f (expected %d)' % (1, y_test[i]))

  else:
      Predicted_output.append(0)
      print('%.2f (expected %d)' % (0, y_test[i]))

# Generate classification report using predictions for binary model
print(" ")
print('Results for Binary Model')
print((accuracy_score(y_test,  Predicted_output))*100)
print(classification_report(y_test,  Predicted_output))